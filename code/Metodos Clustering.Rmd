---
title: 
author: 
date: "2024-12-05"
output: html_document
---
```{r}
library(dendextend)
library(factoextra) #numero optimo
library(dbscan)
library(ggplot2)


```
#K-medoid

#DBSCAN

```{r}
#Referencia: https://github.com/sandipanpaul21/Clustering-in-Python/blob/master/11_DBScan_Clustering.ipynb


PuntosEnCirculo <- function(r, n = 100) {
  points <- data.frame()
  for (x in 1:n) {
    angulo <- 2 * pi / n * x
    points <- rbind(points, data.frame(
      x = cos(angulo ) * r + rnorm(1, 0, 30),
      y = sin(angulo ) * r + rnorm(1, 0, 30)
    ))
  }
  return(points)
}

#Crear circulos 
set.seed(42)

df1 <- PuntosEnCirculo(500, 1000)   
df2 <-PuntosEnCirculo(300, 700)    
df3 <- PuntosEnCirculo(100, 300)    
df <- rbind(df1, df2, df3)

#agregar ruido
set.seed(42)
ruido <- data.frame(
  x = sample(-600:600, 300, replace = TRUE),
  y = sample(-600:600, 300, replace = TRUE)
)

df <- rbind(df, ruido)

# DBCAN caso 1:
dbscan_caso1 <- dbscan(df, eps = 0.5, minPts = 5)

#
df$dbscan_labels <- dbscan_caso1$cluster


ggplot(df, aes(x = x, y = y, color = factor(dbscan_labels))) +
  geom_point(size = 2) +
  scale_color_manual(values = c("grey", "red", "green", "blue")) +
  labs(title = "DBSCAN Clustering", x = "Feature 1", y = "Feature 2") +
  theme_minimal()

# ahora probar uno mejorrado
dbscan_model_opt <- dbscan(df, eps = 30, minPts = 6)

# 
df$dbscan_opt_labels <- dbscan_model_opt$cluster

# Plotting the optimized DBSCAN results
ggplot(df, aes(x = x, y = y, color = factor(dbscan_opt_labels))) +
  geom_point(size = 2) +
  scale_color_manual(values = c("grey", "red", "green", "blue")) +
  labs(title = "Optimized DBSCAN Clustering", x = "Feature 1", y = "Feature 2") +
  theme_minimal()



```
### Observaciones

La función PuntosEnCirculo genera puntos en un patrón circular utilizando funciones seno y coseno. Estos puntos se combinan para formar tres círculos concéntricos con diferentes radios, además añadimos ruido a los datos utilizando valores aleatorios.

-    En el primer gráfico cada clúster está representado por un color diferente. Los puntos de ruido aparecen en color gris en los gráficos.Primero, aplicamos DBSCAN con los parámetros iniciales eps = 0.5 y minPts = 5.

-   En el segundo gráfico, después de observar los resultados del inicial, aplicamos DBSCAN con parámetros optimizados (`eps = 30` y `minPts = 6`) para ver cómo maneja los clústeres de manera más eficaz.



#Clustering Jerarquico
```{r}
USArrests
```
#Escalar
```{r}
data.scaled <- scale(x = USArrests,
                     center = TRUE,
                     scale = TRUE)
head(data.scaled)
```
```{r}
dist      <- dist(data.scaled,method = "euclidean")
# matriz de distancias
dist_mat  <- as.matrix(round(dist,3))
as.dist(dist_mat[1:6,1:6])
```

#numeor optimo de clusters
```{r}
fviz_nbclust(data.scaled, FUN = hcut, method = "silhouette")
```

```{r}
modelo2 <- hclust(dist, method = "complete")
```

```{r}
fviz_dend(modelo2, cex = 0.8, lwd = 0.8, k = 4,
# Seleccionando manualmente los colores
          k_colors = c("red", "green3", "blue", "magenta"),
          rect = TRUE, 
          rect_border = "gray", 
          rect_fill = FALSE)
```
```{r}
# mejorando el tamaño de letra
fviz_dend(modelo2, cex = 0.5, k=4, 
          rect = TRUE,  
          k_colors = "jco",
          rect_border = "jco", 
          rect_fill = TRUE, 
          horiz = TRUE)
```


```{r}
fviz_dend(modelo2, cex = 0.5, k = 4,
                  rect = TRUE,
                  k_colors = "jco",
                  rect_border = "jco",
                  rect_fill = TRUE,
                  type = "phylogenic")
```

```{r}
fviz_dend(modelo2, cex = 0.5, k = 4,
                 rect = TRUE,
                 k_colors = "jco",
                 rect_border = "jco",
                 rect_fill = TRUE,
                 type = "circular")
```


